什么是python全局解释器锁（GIL）？
======
    内容概览 
    · GIL解决了python的什么问题？
    · 为什么选GIL作为解决方案？
    · 对python多线程程序的影响
    · 为什么还没有将GIL移除？
    · 为什么它没有在python3中被移除？
    · 怎么面对python的GIL

Python全局解释器锁（GIL），简单来说，是一种互斥锁（或锁），它允许仅有一个线程拥有python解释器的控制权。  

这意味着在任意时刻仅有一个线程能处在执行状态。GIL的影响对于那些运行单线程程序的开发者并不明显，但是它却能成为多线程的cpu密集型代码的瓶颈。

由于GIL哪怕在多核cpu的多线程架构中也是这幅德行，它便成了python的一个“臭名昭著”的特性。

**在本文中你将了解GIL是如何影响你python程序的性能和怎样才能减轻这些影响**

GIL解决了python的什么问题？
--------
python的内存管理使用了引用计数。这意味着python中创建的对象都有一个计数变量，用来追踪指向这个对象的引用次数。当这个计数归零，这个对象所占用的内存将被释放。

让我们看一段简短的代码示例，它将展示引用计数如何工作：

    >>> import sys
    >>> a = []
    >>> b = a
    >>> sys.getrefcount(a)
    3

在这个例子中，空列表对象`[]`的引用计数是3。该列表对象分别被`a`, `b` 和 传给 `sys.getrefcount()`的参数引用。

回到GIL：

这个引用计数在两个线程同时增加或减少的时候会出现问题，需要保证它不受这种竞争情况的影响。如果不能保证，那么将出现内存泄露甚至是错误地释放一个依然在使用的对象内存。这将导致你的python程序崩溃或者是其他莫名其妙的bug。

引用计数可以通过对所有跨线程的数据结构加锁来保证它们不会被修改成不一致的情形。

但是，对每个对象或对象组加锁意味着将会出现多重锁，而这可能导致另一个问题——死锁（死锁仅会在多于一个锁的时候发生）。而不断地获取和释放锁也将导致性能降低。

GIL是施加在解释器上的一个唯一的锁，任何python字节码必须在获取该锁的条件下执行。这样防止了死锁（因为只有一个锁），而且也不会对性能有太多影响。但是这样就让所有CPU密集型的python程序变成了单线程。
